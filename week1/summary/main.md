# 第一周的学习内容是：
> 书本学习，从3.1节到4.2节；
> 代码练习，第三章关于链表、栈、队列的代码。
# 学习中的一些总结和疑惑：
> 1、3.1中关于ADT的一些内容看得似懂非懂。以集合ADT举的例子不是很理解。作为数据类型，整数、实数及布尔量有与它们相关的操作，而抽象数据类型也有与之相关的操作，可是ADT它的定义不就是一些操作的集合吗，什么叫与一个操作的集合相关的操作

> 2、第一个代码linklist里面，书上基本上给全了各个函数的例程，需要我补的很少，但是写完测试程序开始运行的时候报错内容却多达几十行。我按照书上的声明将typedef……这几行语句放在#ifdef……#endif中间不行，我将它们移到外面却可以。然后就是在初始化链表的时候出现了很大的问题，initial函数里面的参数是L，可是编译的时候警告L还没初始化，可是这一行语句就是为了初始化，似乎陷入了一个死循环里面。最后在CSDN上面看到别人用makeempty去初始化L，里面参数直接设成了NULL，能运行但是我不明白为什么这样就可以，函数里面不是还要给参数赋值吗？为什么NULL能行？其他的这个代码没什么问题了，最后我还另外加了一个按位查找的函数和一个遍历的函数。

> 3、第二个代码是cursorlist，也就是链表的游标实现，它跟第一个的功能都差不多，只不过不使用指针，用数组来代替，关于数组还有一个问题会在之后提到。这个代码没什么大问题，基本上就是P.Next到CursorSpace[P].Next的区别，以及多了一个游标空间的初始化。

> 4、第三个代码stack，它的功能很简单，本质上其实就是一个特殊的链表（这里是用链表实现的），只能在头部添加或删除数据。书上关于栈的应用很多也很有意义，比如第二个关于表达式，利用后缀表达式求值设计得非常巧妙，以及从中缀到后缀的转换也可以用栈来实现，至于函数调用的本质是栈这个在其他课程中也提到过。

> 5、第四个代码是queue，与栈不同的是插入和删除分在两端。按照书上的例程使用数组实现，关于代码，书上这次给的例程很少，基本上都要靠自己去补全，结果很显然，一堆报错。在经过不断调整之后没有报错了去运行，却发现什么也不出来，这个时候才发现没有报错的改bug才最难受，因为不知道去改什么。我能确定肯定哪一步就已经断了导致后面什么也没运行，但是不知道到底哪一步。调试运行的按钮我不太会用，我是在main函数里面我觉得可能有问题的语句前后添加乱码输出，然后首先定位到了Enqueue函数里面的一条语句Q->Array[Q->Rear]=X，但是我不明白这一句为什么有问题，因为Enqueue是书上已经给了给的例程，在我不知道该怎么办的时候，随便在其他函数里面也试试，结果发现以为没问题的Traverse函数后一部分也不能运行，而也刚好是断在了语句printf("%d "，Q->Array[index])，然后我发现共同点是这个数组的使用，我试着在头文件中将结构体QueueRecord里面定义的ElementType  *Array改成了ElementType  Array[size]，发现一切就能正常显示出来了。这里就有一个问题，*Array和 Array[size]这两个之间到底关系是什么，什么时候用哪个才是对的。接着就是在入队的时候发现超出队伍限制了却还是能插入数据，说明IsFull函数有问题，最后我发现队伍已满的判断条件中忘了rear应该模上capacity，导致发生了在已经满了还在继续插入覆盖掉了队头数据的问题。

> 6、最后是关于第四章对树的初步了解，基于之前毕竟学过一遍数据结构，对它还是很亲切的。我觉得树是链表中的一种特殊结构，二叉树的使用能帮我们在很多情况下得到一个更优化的算法，期待下周对树的进一步学习。
# 一些感想：
> 我不知道其他人这一周的学习情况怎么样，我感觉安排之后的每一天真的都挺满的，似乎瞬间将之前一些零零碎碎的空闲时间都挤掉了。问题在于，即使这样，我还是很清楚地感觉到书上很多东西还没有完全学会。
