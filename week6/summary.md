# 第六周的学习内容是：
>书本学习，从11.1节到12.4节；代码练习，第十二章关于伸展树，红黑树，确定性跳跃表，以及AA树的代码。
# 学习的一些总结和感受：
>第十一章关于摊还分析，我觉得是一个挺难理解的一部分，虽然看完了但是绝算不上是真正弄懂了。这里为了从一个易于证明的角度，首先引入了一个附加变量叫作，位势。在看完了这部分之后，我觉得可以这么形象的来解释它，就像是每个月没有花完的生活费攒起来，就类似于位势增加，双十一把之前攒起来的一次性花了大半就类似于位势消耗。位势函数的选择是非常重要且很难的，把程序的实际运行时间和位势的变化加起来就可以得到摊还时间界。第十一章分别分析了二项队列，斜堆，斐波那契堆，伸展树中的各部分操作的摊还时间。只能说是懵懵懂懂的理解了一部分，比如我们需要保证总的序列操作时间加上位势的净变化也就是整个操作的摊还时间是正的，这样提供的上界才算是有意义的，毕竟花费时间不能多于规定的时间。但是对于位势函数的选择理解的还非常浅显，不明白怎样能在一个新给出的结构中选取合适的位势函数。

>第十二章学习了前四个ADT的实现，分别是伸展树，红黑树，跳跃表和AA树，总的来看，都可以说是二叉查找树的变种，第三个跳跃表虽说是表，但有两种实现方法，其中水平数组的实现就很像是B树。它们通过对节点增加标记，来优化自己的性能。比如红黑树采用颜色区分和自定义的规则，使其对比AVL树在给出较宽松的平衡条件的前提下还维持O（logN）的最坏情形下的时间界。而AA树在红黑树的基础上增加了一个新的规则使之比红黑树在插入和删除时要简单一点。它们都是为了维持好的上界并提高运行效率，各个数据结构之间各有特点，在实际情形中很难辨出最好的，比如跳跃表说是要付出空间的代价但在有些时候可能会更少。在下周学完第十二章后，希望对这一章的几种高级数据结构有更统筹性的理解。
